package datastructure.tree;

public class TreeCore {

    /**
     * 树形结构
     *
     *
     */

    /**
     * 树的基本概念
     *  1.节点、根节点、父节点、子节点、兄弟节点
     *  2.一棵树也可以只有1个节点，也就是只有根节点，最多只能有1个根节点
     *  3.一棵树可以没有任何节点，成为空树
     *  4.子树、左子树、右子树
     *  5.节点的度：可以称为子树的个数
     *  6.树的度：所有节点度中的最大值
     *  7.叶子节点：度为0的节点
     *  8.非叶子节点：度不为0的节点
     *  9.层数：根节点在第1层，根节点的子节点在第2层，以此类推（有些可能以0开始）
     *  10.节点的深度：从根节点到当前节点的唯一路径上的节点总数
     *  11.节点的高度：从当前节点到最远叶子节点的路径上的节点总数   （个人补充见解：该节点其子树下面的最远叶子节点！！！）
     *  12.树的深度：所有节点深度中的最大值
     *  13.树的高度：所有节点高度中的最大值
     *  14.树的高度 等于 树的深度
     *
     *  15.有序树：树中任意节点的子节点之间有顺序关系
     *  16.无序树：树中任意节点的子节点之间没有顺序关系，也称为自由树
     *  17.森林：由n棵互不相交的树组成的集合，（n >= 0）
     */



    /**
     * 二叉树：
     *
     *  1.每个节点的度最大为2（最多拥有两个子树）
     *  2.左子树和右子树是有顺序的
     *  3.即使某节点只有一颗子树，也要区分左右子树
     *  4.非空二叉树的 第i层，最多有2的i - 1次方 个节点 (i >= 1)
     *  5.高度为h的二叉树上，最多有2的h次方 - 1 个节点 (h >= 1)
     *  6.对于任何一颗非空二叉树，如果叶子节点的个数为n0，度为2的节点个数为n2，则有：n0 = n2 + 1树形结构
     *  7.假设度为1的节点个数为n1，那么二叉树的节点总数 n = n0 + n1 + n2
     *  8.二叉树的边数 T = (n1 + 2 * n2) ， (n - 1) ， (n0 + n1 + n2 - 1) 这三个公式都可以推算出来
     *  9.二叉树的第i层，节点数量为 2的i次方 - 1个
     *    h为二叉树高度，叶子节点数量为：2的h次方 - 1个
     *    总节点数 n = (2的h次方 - 1)，(2的0次方 + 2的1次方 + ..... + 2的h次方 - 1)
     *    二叉树高度 h = log2(n + 1)
     *
     * 10.平衡：当节点数量固定时，左右子树的高度越接近，这颗二叉树就越平衡（高度越低）
     *
     *
     *  真二叉树：所有节点的度要么为0，要么为2，也就是代表，要么没有，要么有两个叉
     *  满二叉树：所有节点的度要么为0，要么为2，且所有的叶子节点都在最后一层，（完完整整）
     *
     *  完全二叉树：叶子节点只会出现最后2层，且最后1层的叶子节点都靠左对齐，度为一的节点只有左子树，度为一的节点要么1个，要么0个，出现度为一的正确节点或者叶子节点之后，从左向右，之后的节点必须是叶子节点。
     *
     *  同样节点数量的二叉树，完全二叉树的高度最小
     *  树高度 h = floor(log2n) + 1
     *  假设完全二叉树的高度为h，那么最少有2的h - 1次方个节点，最多2的h次方 - 1个节点
     *
     *  假如有n个节点，节点有序编号，编号i的父节点编号为floor(i/2)，如果2i <= n，它的左子节点编号为2i，右子节点编号为2i + 1。
     *  2i > n则没有左子节点，2i + 1 > n则没有右子节点
     *
     *  叶子节点个数计算公式：floor((n + 1) / 2)
     *  非叶子节点个数计算公式: floor(n / 2)
     *  （完全二叉树从根节点到倒数第2层是一颗满二叉树）
     *
     *  同样高度的二叉树中，满二叉树的叶子节点数量最多、总节点数量最多。
     *  满二叉树一定是真二叉树，真二叉树不一定是满二叉树。
     *
     *
     *
     *
     *
     *  二叉树遍历分为4种常见遍历：前序遍历、中序遍历、后序遍历、层序遍历
     *  前序遍历：遍历顺序为 根节点 -> 前序遍历（左||右）子树 -> 前序遍历（左||右）子树
     *  中序遍历：遍历顺序为 中序遍历（左||右）子树 -> 根节点 -> 中序遍历（左||右）子树
     *  后序遍历: 遍历顺序为 后序遍历（左||右）子树 -> 后序遍历（左||右）子树 -> 根节点
     *  层序遍历：从上往下、从左往右依次访问每一个节点
     *
     *  前驱节点：中序遍历时的前一个节点，例如：中序遍历结果为 [1、2、3、4、5、6、7、8、9、10]，[7]的前驱节点是[6]，
     *  寻找公式：{node.left != null 然后 node.left.right.right......，直到节点n的右为空，前驱节点为节点n}，如果前面未找到，
     *  则 {node.parent != null 然后 node.parent.parent.parent.....，直到节点n是父节点的右子树 == 节点n，前驱节点为节点n}，否则没有前驱
     *  (二叉搜索树：该节点左子树最大的，没有左子树，层层父节点小于该节点的)
     *
     *  后驱节点：中序遍历时的后一个节点，例如：中序遍历结果为 [1、2、3、4、5、6、7、8、9、10]，[7]的后驱节点是[8]，
     *  寻找公式与上面其反之：{node.right != null 然后 node.right.left.left......，直到节点n的左为空，后驱节点为节点n}，如果前面未找到，
     *  则 {node.parent != null 然后 node.parent.parent.parent.....，直到节点n是父节点的左子树 == 节点n，后驱节点为节点n}，否则没有后驱
     *  (二叉搜索树：该节点右子树最小的，没有右子树，层层父节点大于该节点的))
     */


    /**
     * 二叉搜索树:
     * 任意一个节点的值都大于其左子树所有节点的值
     * 任意一个节点的值都小于其右子树所有节点的值
     * 它的左右子树也是一颗二叉搜索树
     * 存储的元素必须具备可比较性
     *
     * 时间复杂度：O(logn) 添加删除搜索，树的高度多少，最坏的复杂度为多少。
     */

    /**
     * 平衡二叉搜索树：(Balanced Binary Search Tree)
     * 一颗达到适度平衡的二叉搜索树，可以称之为（自）平衡二叉搜索树
     * 用尽量少的调整次数达到适度平衡即可，常见的有：AVL树、红黑树
     *
     *
     *
     * AVL树：
     * 平衡因子：某节点的左右子树的高度差（左子树高度减去右子树高度的值）
     * 每个节点的平衡因子只可能是1、0、-1（绝对值 <= 1，如果超过1，称之为失衡）
     * 也就是每个节点的左右子树高度差不超过1
     * 添加删除搜索的时间复杂度是O(logn)
     * 失衡节点的父节点-祖先节点都可能会失衡，都可能会被影响，非失衡节点的父节点-祖先节点不受影响
     *
     *
     * r = 旋转节点，rl = 旋转节点的左子树，rr = 旋转节点的右子树
     *
     * LL情况 右旋（单旋） LL代表：左子树的左子树导致失衡 left-left 也就是左边的左边导致失衡，使用右旋保证平衡
     * 操作公式为 r.left = rl.right; rl.right = r;  （相对）rl就变了这棵子树的根节点了
     * 也就是旋转节点的左子树 = 原左子树的右子树，原左子树的右子树 = 旋转节点，这棵子树的（相对）根节点 = 原左子树
     * 也要对应维护 每个参与变化节点的parent属性更新、r和rl的高度更新
     *
     * RR情况 左旋（单旋） RR代表：右子树的右子树导致失衡 right-right 也就是右边的右边导致失衡，使用左旋保证平衡
     * 操作公式为 r.right = rr.left; rr.left = r;  （相对）rr就变了这棵子树的根节点了
     * 也就是旋转节点的右子树 = 原右子树的左子树，原右子树的左子树 = 旋转节点，这棵子树的（相对）根节点 = 原右子树
     * 也要对应维护 每个参与变化节点的parent属性更新、ib和ibr的高度更新
     *
     * LR情况 因为是LR，所以需要找单向情况，L后面是R，不是单向，应该看R和后面，后面没了，默认是一样的R情况，所以对R的那个子树进行RR左旋转，然后就是LL情况，再对第一个L的那个子树LL右旋转。 也就是 先RR左旋转 再LL右旋转（双旋转）
     * RL情况 先LL右旋转 再RR左旋转（双旋转）
     */
}
