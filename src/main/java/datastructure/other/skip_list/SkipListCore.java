package datastructure.other.skip_list;

public class SkipListCore {

    /**
     * 跳表：
     * 是在有序链表的基础上增加了 “跳跃” 的功能，又叫做跳跃表、跳跃列表
     *
     * 可以看作是有序链表的二分查找，设计的初衷是为了取代平衡树（比如红黑树）
     *
     * 对比平衡树：
     * 跳表的实现和维护会更加简单                        （实现更容易理解，红黑树的实现非常复杂，所以维护困难）
     * 跳表的搜索、删除、添加的平均时间复杂度是O(logn)
     *
     * 应用：
     * Redis中的SortedSet，LevelDB中的MemTable都用到了跳表
     */


    /**
     * 查询：
     * 从顶层首元素开始，从左往右搜索，直到找到一个大于等于的元素 或者 达到当前层的链表的尾部
     * 如果 该元素 == 目标元素，则表明该元素已经被找到
     * 如果 该元素 > 目标元素 或者 已经达到当前层链表尾部，则返回当前层的前一个元素，然后转入下一层进行搜索    （说明目标元素在前一个元素和该元素之间，从前一个元素转入下一层开始搜索，如果无法再转入下一层，已经是最底层，代表没找到）
     *
     *
     * 添加：
     * 进行逐层搜索，查询元素是否存在，并且记录要添加元素的每一层前驱节点   （每层最后一个小于自己的节点，也就是遇到大于等于的元素的前一个）
     * 如果 添加元素 存在，则直接替换
     * 如果 添加元素 不存在，则可以添加，然后通过 随机抛硬币 决定层数，根据层数，将找到的各层前驱节点的next指向自己，自己指向原本的后继节点，插入成功
     * 如果添加元素的层数高于有效层数，则高于的那些层的前驱节点就是first，并且更新一下最高有效层数     （跳表变高）
     *
     *
     * 删除：
     * 从顶层首元素开始，从左往右搜索，查询元素是否存在，并且记录要删除元素的每一层前驱节点   （每层最后一个小于自己的节点，也就是遇到大于等于的元素的前一个）
     * 如果 删除元素 不存在，则说明不用删，结束
     * 如果 删除元素 存在，则可以删除，根据要删除元素的层数，将找到的各层前驱节点的next指向自己的next，删除成功
     * 如果每层删除之后，那层的first直接指向null，则有效层数--    （代表被删除元素原本是那层唯一的元素，跳表变低）
     *
     *
     * 抛硬币的概率为P，通常为四分之一、二分之一概率增高层数
     *
     * 跳表的搜索、添加、删除的平均时间复杂度是O(logn)
     */


    /**
     * 跳表的层数：
     * 跳表是按层构造的，底层是一个普通的有序链表，高层相当于是低层的 “快速通道”   （可以跳过下一个节点，直接到达往后的节点）
     * 第i层中的元素，按某个 固定概率P 出现在第 i + 1 层中，产生越高的层数，概率越低        （P通常为4分之一，或者2分之一，每次抛硬币有P的概率，增高层数，每次都能中四分之一的几率很低）
     *
     * 元素层数恰好等于     1 的概率为 1 - P
     * 元素层数恰好大于等于 2 的概率为 P
     * 元素层数恰好大于等于 3 的概率为 P ^ 2   (0.25 * 0.25 = 0.0625)
     *
     *
     * 一个元素的平均层数是 1 / (1 - P)
     * 当 P = 2分之一时，每个元素所包含的平均指针数量是2      （1 / (1 - 0.5) = 2，平均2层）
     * 当 P = 4分之一时，每个元素所包含的平均指针数量是1.33   （1 / (1 - 0.25) = 1.33，平均1.33层）
     */


    /**
     * 跳表的复杂度分析：
     * 第 1 层链表固定有 n 个元素          （10）
     * 第 2 层链表平均有 n * p 个元素      （10 * 0.25 = 2.5）
     * 第 k 层链表平均有 n * p ^ k 个元素  （10 * 0.25 * 0.25 = 0.625）
     *
     * 最高层的层数是 log1/p(n)，最高层平均有1 / p个元素
     * 在搜索时，每一层链表的预期查找步数最多是 1 / p，所以总的查找步数是 最高的层数 * 每层查找步数，也就是 log1/p(n) * 1 / p  =  -(logp(n / p))
     * P是常数，负负得正，所以时间复杂度是O(logn)
     */
}
