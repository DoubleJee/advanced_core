package datastructure.other.bloom_filter;

public class BFCore {

    /**
     * 布隆过滤器：
     * 它是一个空间效率高的概率型数据结构，可以用来告诉你：一个元素一定不存在或者可能存在
     *
     * 本质上是一个很长的二进制向量和一系列随机映射函数（Hash函数）组成
     *
     * 优点：空间效率和查询时间都远远超过一般的算法
     * 缺点：有一定的误判率、删除困难     （误判率可以控制很低，但是无法删除）
     *
     * 常见应用：网页黑名单系统、垃圾邮件过滤系统、爬虫网址判重系统、解决缓存穿透问题
     */


    /**
     * 布隆过滤器的原理：
     * 假设我们的布隆过滤器由 20位二进制、3个哈希函数 组成，每个元素经过哈希函数处理都能生成一个索引位置
     *
     * 添加元素：将每一个哈希函数生成的索引位置都设为1 （代表该元素存在）
     * 查询元素：
     *  如果有一个哈希函数生成的索引位置不为1，就代表一定不存在    （100%准确）
     *  如果每一个哈希函数生成的索引位置都为1，就代表可能存在      （存在一定的误判率）
     */


    /**
     * 布隆过滤器的误判率：
     * 误判率 p 受三个因素影响：二进制位的个数m，哈希函数的个数k，数据规模n
     * p = (1 - e ^ -( (k * n) / m )) ^ k         （自然常数e的值 ≈ 2.7182818）
     *
     *
     * 已知误判率p、数据规模n， 求得二进制位的个数m、哈希函数的个数k
     *
     * m = -( (n * lnp) / (ln2 ^ 2) )，   前面的-代表后面运算的值加个负号，可能是负负得正         （ln就是loge()，以自然常数e为底，常数e的值 ≈ 2.7182818，ln2就是loge(2)，求2的对数以e为底，也就是2能被e除以多少次，lnp是loge(p) ）
     * k = m / n * ln2
     *
     * 通过上面的公式，我们可以通过数据规模n和期望误判率p，来计算出需要用多长的二进制位、几个哈希函数
     */


    /**
     * 布隆过滤器的复杂度：
     *
     * 时间复杂度：O(k)， k是哈希函数的个数
     * 空间复杂度：O(m)， m是二进制位个数
     */
}
