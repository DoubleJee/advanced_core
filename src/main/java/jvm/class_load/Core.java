package jvm.class_load;

public class Core {


    /**
     *  类加载过程：
     *  加载、验证、准备、解析、初始化、使用、卸载。  总共7个阶段，也是类的生命周期
     *
     *  验证、准备、解析，三个阶段统称为成为连接
     *
     *  加载、验证、准备、初始化、卸载这五个阶段的顺序是确定的，而解析阶段不一定，可能在初始化阶段之后再开始
     *
     *  类加载的第一个阶段"加载"，《Java虚拟机规范》没有强制约束，可以虚拟机具体实现来自由把握
     *
     */


    /**
     *
     *  类加载的 "初始化" 阶段，有着严格规定。只有六种情况会对类进行初始化（加载验证准备自然需要在此之前），这些情况也被称为主动引用。
     *
     *      1.遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类型还没有进行过初始化，则需要先出发其初始化阶段，
     *      这四条指令对应的Java代码场景为：
     *
     *          1.1：使用new关键字实例化对象的时候
     *          1.2：读取或设置一个类型的静态字段的时候。（被final修饰、已在编译期就已经把结果放入常量池的静态字段除外）
     *          1.3：调用一个类型的静态方法的时候。
     *
     *
     *      2.使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有被初始化，则需要先触发其初始化。
     *
     *      3.当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
     *
     *      4.当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个主类
     *
     *      5.JDK7 新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为
     *      REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，
     *      并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化
     *
     *      6.当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，
     *      如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。
     *
     *  这六种情况被称为对一个类型进行主动引用。除此之外所有的引用类型的方式都不会触发初始化，被称为被动引用
     *
     */


    /**
     *
     * “通过一个类的全限定名来获取描述该类的二进制字节流”，这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。
     *  实现这个动作的代码被称为“类加载器”（Class Loader）。
     *
     * 比如从网络中获取，从压缩包中读取（jar、ear、war）
     * 获取二进制字节流是类加载器
     * 类加载器可以控制获取class字节流的获取方式
     *
     *
     * 对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，
     * 每一个类加载器，都拥有一个独立的类名称空间。
     * 这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，
     * 否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。
     *
     * BootStrap类加载器，启动类加载器 加载JAVA_HOME/lib下的核心jar包，会根据名称加载，不会随便加载（rt.jar），用户自定义的不在名单中，不会加载
     * java代码无法引用，属于C++实现
     *
     * Extension类加载器，扩展类加载器 加载JAVA_HOME/lib/ext下的扩展jar包，用户可以直接引用
     *
     * Application类加载器，应用类加载器 加载用户类路径上的所有类库，classpath，
     * 如果应用程序中没有自定义过自己的类加载器，一般情况下就是程序默认的类加载器
     *
     * 双亲委派：把加载请求委派自己的父加载器去做（实际是组合实现的父子关系），父加载器做不了，自己再做，这样有效避免重复加载，保证核心类库安全，防止被篡改
     *          按照从小到大顺序 用户类加载器 -> application -> ext -> bootstrap 委派链
     *
     *          双亲委派实现逻辑在ClassLoader的loadClass方法里。
     *
     *
     * 破坏双亲委派：重写ClassLoader的loadClass方法即可破坏双亲委派，
     * findClass是不会破坏双亲委派，属于当前加载器自己去做的方法，当父都没有加载成功的话，自己去加载
     *
     */
}
