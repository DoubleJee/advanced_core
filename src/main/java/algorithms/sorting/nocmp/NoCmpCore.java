package algorithms.sorting.nocmp;

public class NoCmpCore {

    /**
     * 非比较排序
     *
     * 计数排序、基数排序、桶排序，都是不是基于比较的排序
     * 它们是典型的 空间换时间，在某些情况下，平均时间复杂度可以比O(nlogn)更低
     */


    /**
     * 计数排序：
     * 适合对一定范围内的整数进行排序
     * 统计每个整数在序列中出现的次数，进而推导出每个整数在有序序列中的索引 （通过索引从小到大的机制帮忙排序）
     * 如果自定义对象提供可以用来排序的整数类型，也可以使用计数排序
     *
     *
     * k是取值范围长度
     *
     * 时间复杂度：最好、最坏、平均：O(n + k)
     *
     * 空间复杂度：O(n + k)，一样长度的排序数组 + k长度的次数统计数组
     *
     * 在k取值范围不是很大的情况下，性能可能会快过O(nlogn)的排序
     *
     * 稳定、非原地算法
     */


    /**
     * 基数排序
     * 非常适合用于整数排序（尤其是非负整数），只写对非负整数的排序（负整数的稍微复杂）
     *
     * 执行流程：依次对 个位数、十位数、百位数、千位数、万位数...进行排序（从低位到高位）
     *
     * 因为个位数、十位数等 取值范围都是0~9，可以使用计数排序对它们进行排序
     *
     * d是最大值的位数，k是进制，大多都是十进制
     *
     * 时间复杂度：最好、平均、最坏：O(d * (n + k))，因为是d个位数，分别来d次计数排序
     * 空间复杂度：O(n + k)，因为计数排序，一样的排序数组 + 取值范围数组
     *
     * 稳定、非原地算法
     */


    /**
     * 桶排序
     * 1.创建一定数量的桶（比如用数组、链表作为桶）
     * 2.按照一定规则，将序列中的元素均匀分配到对应的桶（不同类型数据的规则不同）
     * 3.分别对每个桶进行单独排序
     * 4.将所有非空桶的元素合并成有序序列
     *
     * 桶排序比较个性化，根据自己定的规则，可以决定怎么把元素均匀分配到对应的桶，自己决定桶单独排序的方式，属于方法论型的排序
     *
     * 桶之间是有序的，0号桶，1号桶，最后桶合并，0号桶的数据都比1号桶的数据小，合并成有序
     *
     *
     * 自己写的小数桶排序 （m是桶的数量）
     * 时间复杂度：O(n + k)，n元素放入桶 + 假设每个桶均匀，所有桶进行的排序就是 k = m * O((m / n) * log(m / n))，最后推出来就是 k = (n * logn - n *logm)，最终复杂度：n次元素放桶 + k次桶内排序
     *
     * 空间复杂度：O(n + m)，m是桶的数量，n是那些桶总共存储的还是原来一样规模的元素
     *
     * 稳定、非原地算法
     */


}
