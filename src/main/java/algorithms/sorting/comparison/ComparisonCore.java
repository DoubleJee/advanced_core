package algorithms.sorting.comparison;

public class ComparisonCore {
    /**
     * 比较排序
     */

    /**
     * 冒泡排序：
     * 1. 从头开始比较每一对相邻元素，如果第1个比第2个大，就交换它们的位置（执行完一轮后，最末尾的元素就是最大的元素）
     * 2. 忽略步骤1中曾经找到的最大元素，重复执行步骤1，直到全部元素有序
     *
     *
     * 稳定算法，原地算法
     *
     * 时间复杂度
     * 最好：O(n)
     * 最坏、平均：O(n^2)
     *
     * 空间复杂度：O(1)
     */


    /**
     * 选择排序：
     * 1.从序列中找出最大的那个元素，然后与最末尾的元素交换位置（执行完一轮后，最末尾的元素就是最大的元素）
     * 2.忽略步骤1中曾经找到的最大元素，重复执行步骤1，最后元素有序
     *
     * 稳定、原地算法
     *
     * 时间复杂度：均为O(n^2)，空间复杂度：O(1)
     */


    /**
     * 堆排序：     可以看作是对选择排序的优化，选择阶段使用堆来寻找最大元素
     * 1.对序列原地建堆
     * 2.重复以下步骤，直到堆的元素数量为1，最后元素有序
     *  交换堆顶元素和尾元素
     *  堆的元素数量 -1
     *  将0位置（新堆顶）进行1次SiftDown下滤操作
     *
     * 不稳定、原地算法
     * 时间复杂度：均为O(nlogn)，空间复杂度：O(1)
     *
     */



}
