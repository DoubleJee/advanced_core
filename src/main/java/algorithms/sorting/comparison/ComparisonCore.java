package algorithms.sorting.comparison;

public class ComparisonCore {
    /**
     * 比较排序
     */

    /**
     * 冒泡排序：
     * 1. 从头开始比较每一对相邻元素，如果第1个比第2个大，就交换它们的位置（执行完一轮后，最末尾的元素就是最大的元素）
     * 2. 忽略步骤1中曾经找到的最大元素，重复执行步骤1，直到全部元素有序
     *
     *
     * 稳定算法，原地算法
     *
     * 时间复杂度
     * 最好：O(n)
     * 最坏、平均：O(n^2)
     *
     * 空间复杂度：O(1)
     */


    /**
     * 选择排序：
     * 1.从序列中找出最大的那个元素，然后与最末尾的元素交换位置（执行完一轮后，最末尾的元素就是最大的元素）
     * 2.忽略步骤1中曾经找到的最大元素，重复执行步骤1，最后元素有序
     *
     * 稳定、原地算法
     *
     * 时间复杂度：均为O(n^2)，空间复杂度：O(1)
     */


    /**
     * 堆排序：     可以看作是对选择排序的优化，选择阶段使用堆来寻找最大元素
     * 1.对序列原地建堆
     * 2.重复以下步骤，直到堆的元素数量为1，最后元素有序
     *  交换堆顶元素和尾元素
     *  堆的元素数量 -1
     *  将0位置（新堆顶）进行1次SiftDown下滤操作
     *
     * 不稳定、原地算法
     * 时间复杂度：均为O(nlogn)，空间复杂度：O(1)
     */


    /**
     * 插入排序：
     * 1.在执行的过程中，插入排序会将序列分为2部分
     *  头部是已经排好序的，尾部是待排序的
     *
     * 2.从头扫描每一个元素
     *  每当扫描一个元素，就将它插入头部合适的位置，使得头部数据依然保持有序 （一开始第1个元素可以默认当头部，然后从尾部，从头到尾扫描）
     *
     *
     * 逆序对：在升序情况下，任意的两个数字，在前面顺序的一个数字 大于 在后面顺序的一个数字，这俩数字就是一个逆序对
     * 数组[2,3,8,6,1]，逆序对为：<2,1> <3,1> <8,1> <8,6> <6,1>
     *
     * 插入排序的 复杂度 与 逆序对的数量 成正比关系
     * 逆序对的数量越多，插入排序的时间复杂度越高
     * 逆序对的数量越少，插入排序的时间复杂度越低
     *
     * 逆序对数量极少时，甚至速度比O(nlogn)级别的快速排序还要快
     * 数据量不是特别大的时候，插入排序的效率也是非常好的
     *
     * 稳定、原地算法
     *
     * 时间复杂度：
     * 最好：O(n)
     * 最坏、平均：O(n^2)
     *
     * 空间复杂度：O(1)
     *
     */


}
