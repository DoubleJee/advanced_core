package algorithms;

public class Core {
    /**
     * 算法：用于解决特定问题的一系列执行步骤
     */

    /**
     * 算法批判维度：
     *  基本：
     *       正确性：算法结果是否正确
     *       可读性：让人容易理解，看得懂
     *       健壮性：对不合理输入的反应能力（不会异常）和处理能力（计算速度）
     *  高级：
     *      时间复杂度：估算程序指令的执行次数（执行时间），如：;号结尾一句指令。
     *      空间复杂度：估算所需占用的存储空间
     */

    /**
     * 时间复杂度：
     *
     *    O() 表示数据规模n对应的复杂度，忽略以下
     *         常数：固定不变的值
     *         系数、低阶
     *
     *    log2(n) n的2次幂  n能被2整除几次
     *
     *
     *    9 >> O(1)     忽略常数9
     *    2n + 3 >> O(n)  忽略系数2，常数3
     *    n^2 + 2n + 6 >> O(n^2) 直接取高阶：n^2。 2n、6低阶忽略
     *    4n^3 + 3n^2 + 22n + 100 >> O(n^3) 直接取高阶 4n^3。系数4忽略
     *    log2(n) >> O(logn)  忽略系数2，log(n)
     *
     *    时间最短排序：O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(2^n)
     *
     *    用尽量少的存储空间，用尽量少的执行步骤（次数），根据情况可以用空间换时间或时间换空间
     *
     */

    /**
     * 算法常见递推式与复杂度
     *
     * T(n) = 数据规模n进行计算，所需要时间的递推式
     *
     * T(n)   =   T(n / 2) + O(1)       = O(logn)
     * T(n)   =   T(n - 1) + O(1)       = O(n)
     * T(n)   =   T(n / 2) + O(n)       = O(n)
     * T(n)   =   2 * T(n / 2) + O(1)   = O(n)
     * T(n)   =   2 * T(n / 2) + O(n)   = O(nlogn)
     * T(n)   =   T(n - 1) + O(n)       = O(n^2)
     * T(n)   =   2 * T(n - 1) + O(1)   = O(2^n)
     * T(n)   =   2 * T(n - 1) + O(n)   = O(2^n)
     *
     */

    /**
     * 排序算法：
     * 十大排序算法
     */

    /**
     * 二分查找、递归、回溯、剪枝、贪心、分治、动态规划
     */

}
