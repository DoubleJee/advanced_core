package algorithms.recursion;

public class RecursionCore {

    /**
     * 递归：
     * 函数直接或间接调用自身，是一种常用的编程技巧
     * 递进、归来
     *
     * 递归求出来的很有可能不是最优方案，但也有可能是最优方案  （效率）
     */

    /**
     * 递归基：
     * 如果递归调用没有终止，将会一直消耗栈空间，最后会导致栈内存溢出（Stack Overflow）
     * 所以需要有一个明确的结束递归的条件，也叫作：边界条件、递归基
     */

    /**
     * 递归的基本思想：
     *
     * 拆解问题：
     * 把规模大的问题变成规模较小的同类型问题
     * 规模较小的问题又不断变成规模更小的问题
     * 规模小到一定程度可以直接求出它的解
     *
     * 求解问题：
     * 由最小规模问题的解得出较大规模问题的解
     * 由较大规模问题的解不断得出规模更大问题的解
     * 最后得出原来问题的解
     *
     * 凡是可以利用上述思想解决问题的，都可以尝试使用递归
     * 如：链表、二叉树的相关问题都可以使用递归来解决，因为它们本身就是递归的结构（链表中包含链表，二叉树中包含二叉树，每段拿出来都是一个链表、一个二叉树）
     *  小规模问题和大规模问题求解的方式一样就可以尝试使用递归
     */

    /**
     * 递归的使用套路（实践）：
     *
     * 1.明确函数的功能：   先不要去思考里面代码怎么写，首先搞清楚这个函数是干嘛用的，能完成什么功能？
     * 2.明确原问题与子问题的关系：  寻找 f(n) 与 f(n - 1)、f(n - 2) 的关系，也就是找原问题与缩小规模问题的关系
     * 3.明确递归基： 递归的过程中，子问题的规模在不断减小，问题规模小到什么程度可以直接得出解？
     */


    /**
     * 递归调用的空间复杂度：
     * 递归深度 * 每次调用所需要的辅助空间
     */

    /**
     * 递归转非递归：
     * 递归100%百分之百可以转换成非递归
     *
     * 转非递归的万能方法：自己维护一个栈，来保存参数，局部变量，模拟函数调用栈，但是空间复杂度依然没有得到改善优化
     * 另一种方法：在某些时候，也可以重复使用一组相同的变量来保存每个栈帧内容，空间复杂度可以降低
     */


    /**
     * 尾调用：
     * 一个函数的最后一个动作是调用函数
     * 如果最后一个动作是调用自身，叫做尾递归，是特殊的尾调用
     *
     *
     * 尾调用优化：
     * 一些编译器能对尾调用进行优化，以达到节省栈空间的目的
     * 比如test1尾调用test2，那就不用再次创建栈帧，直接将这个栈帧清空给test2用，重复利用     （test2需要的栈帧比较大的话，将test1栈帧拉长给test2用，add esp, 10h）
     *
     * 如果当前栈帧上的局部变量等内容都不需要用了，当前栈帧经过适当的改变后，可以直接当做尾调用的栈帧使用，然后程序jump到被尾调用的函数代码     （jump到函数业务逻辑代码，不jump到函数头）
     * 生成栈帧改变代码与jump的过程称作 尾调用消除 或者 尾调用优化
     * 尾调用优化让位于尾位置的函数调用跟goto语句性能一样高
     *
     * 消除尾递归比消除一般尾调用容易得多    （因为尾递归不需要改变栈大小）
     * JVM会消除尾递归，但不会消除一般的尾调用   （因为JVM不能动态改变栈帧）
     * 递归代码可以考虑尽量使用尾递归的形式，可以减少栈深度，空间复杂度能从O(n)降低至O(1)
     */



}
