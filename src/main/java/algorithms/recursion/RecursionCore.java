package algorithms.recursion;

public class RecursionCore {

    /**
     * 递归：
     * 函数直接或间接调用自身，是一种常用的编程技巧
     * 递进、归来
     */

    /**
     * 递归基：
     * 如果递归调用没有终止，将会一直消耗栈空间，最后会导致栈内存溢出（Stack Overflow）
     * 所以需要有一个明确的结束递归的条件，也叫作：边界条件、递归基
     */

    /**
     * 递归的基本思想：
     *
     * 拆解问题：
     * 把规模大的问题变成规模较小的同类型问题
     * 规模较小的问题又不断变成规模更小的问题
     * 规模小到一定程度可以直接求出它的解
     *
     * 求解问题：
     * 由最小规模问题的解得出较大规模问题的解
     * 由较大规模问题的解不断得出规模更大问题的解
     * 最后得出原来问题的解
     *
     * 凡是可以利用上述思想解决问题的，都可以尝试使用递归
     * 如：链表、二叉树的相关问题都可以使用递归来解决，因为它们本身就是递归的结构（链表中包含链表，二叉树中包含二叉树，每段拿出来都是一个链表、一个二叉树）
     */

    /**
     * 递归的使用套路（实践）：
     *
     * 1.明确函数的功能：   先不要去思考里面代码怎么写，首先搞清楚这个函数是干嘛用的，能完成什么功能？
     * 2.明确原问题与子问题的关系：  寻找 f(n) 与 f(n - 1)、f(n - 2) 的关系，也就是找原问题与缩小规模问题的关系
     * 3.明确递归基： 递归的过程中，子问题的规模在不断减小，问题规模小到什么程度可以直接得出解？
     *
     */


    /**
     * 递归调用的空间复杂度：递归深度 * 每次调用所需要的辅助空间
     */


}
